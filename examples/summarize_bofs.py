# -*- coding: utf-8 -*-
# Generate JSON data that summarizes beacon object file
# (BOF) commands that are defined by a sleep script.

import json
from sleepy.parser import *
import sys

def concatenate_strings(node):
    if isinstance(node, string):
        return node
    elif isinstance(node, BinOp) and node.op == '.':
        return concatenate_strings(node.left) + node.right
    else:
        raise "Only expected a string or string concatenation but received: {}".format(node)

bofs = dict()
def find_beacon_command_register(node):
    if isinstance(node, Call) and node.function == 'beacon_command_register':
        # We're assuming that the bof name matches the command name in the help information
        args = node.args
        if args[0].value in bofs:
            # We're assuming the simple format of beacon_command_register("", "", "") is used,
            # or that arguments are strings concatenated together (e.g., "" . "")
            bofs[args[0].value]['help_short'] = concatenate_strings(args[1].value)
            bofs[args[0].value]['help_long'] = concatenate_strings(args[2].value)
    return node

beaconInlineExecuteInstances = list()
def find_beacon_inline_execute(node):
    global beaconInlineExecutePresent
    if isinstance(node, Call) and node.function == 'beacon_inline_execute':
        beaconInlineExecuteInstances.append(node)
    return node

bofArgFormats = list()
def find_bof_pack(node):
    if isinstance(node, Call) and node.function == 'bof_pack':
        # We're assuming the simple format of bof_pack(, "", ...) is used
        bofArgFormats.append(node.args[1].value)
    return node

if len(sys.argv) > 1:
    path = sys.argv[1]
    with open(path, 'r') as file:
        parser = SleepParser(quiet=True)
        script = parser.parse(file.read(), tracking=True)
        # Filter any empty statements that may have been generated by syntax errors
        script.body = [_ for _ in script.body if _]
        # Enumerate all of the declared beacon commands that use a bof
        for statement in script.body:
            # First enumerate all beacon commands
            if isinstance(statement, EnvBridge) and statement.keyword == 'alias':
                aliasBridge = statement
                commandName = aliasBridge.identifier
                # Enumerate all statements in the alias's body looking
                # for all uses of beacon_inline_execute
                beaconInlineExecuteInstances = list()
                walk(aliasBridge, find_beacon_inline_execute)
                # If the alias is used to execute a BOF then process it further
                if len(beaconInlineExecuteInstances) > 0:
                    # Enumerate all statements in the alias's body looking
                    # for all uses of bof_pack
                    bofArgFormats = list()
                    walk(aliasBridge, find_bof_pack)
                    # Use set to reduce the list to unique values
                    bofs[commandName] = {
                        'arg_formats': list(set(bofArgFormats))
                    }
        # Enumerate all of the registered help information for all bofs
        walk(script, find_beacon_command_register)
    print(json.dumps(bofs, indent=4))
else:
    print('{} <path>'.format(sys.argv[0]))