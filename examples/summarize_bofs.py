# -*- coding: utf-8 -*-
# Generate JSON data that summarizes beacon object file
# (BOF) commands that are defined by a sleep script.

import json
from sleepy.parser import *
import sys

# Helper class to extend json to serialize sets
class JsonEncoder(json.JSONEncoder):
    def default(self, node):
        if isinstance(node, set):
            return sorted(list(node))
        return json.JSONEncoder.default(self, node)
    
def concatenate_strings(node):
    if isinstance(node, string):
        return node
    elif isinstance(node, BinOp) and node.op == '.':
        return concatenate_strings(node.left) + node.right
    else:
        raise RuntimeError("Only expected a string or string concatenation but received: {}".format(node))

beaconCommands = dict()
def find_beacon_command_register(node):
    if isinstance(node, Call) and node.function == 'beacon_command_register':
        # We're assuming the simple format of beacon_command_register("", "", "") is used,
        # or that arguments are strings concatenated together (e.g., "" . "")
        args = node.args
        beaconCommands[args[0].value] = {
            'help_short': concatenate_strings(args[1].value),
            'help_long': concatenate_strings(args[2].value),
            'arg_formats': set()
        }
    return node
    
bofArgFormats = set()
def find_bof_pack(node):
    global bofArgFormats
    if isinstance(node, Call) and node.function == 'bof_pack':
        bofArgFormats |= {node.args[1].value}
    return node

if len(sys.argv) > 1:
    path = sys.argv[1]
    with open(path, 'r') as file:
        parser = SleepParser(quiet=True)
        script = parser.parse(file.read(), tracking=True)
        # Filter any empty statements that may have been generated by syntax errors
        script.body = [_ for _ in script.body if _]
        # Enumerate all beacon beaconCommands
        walk(script, find_beacon_command_register)
        # Filter the beacon beaconCommands to the ones that use a bof
        # We're assuming that the bof name matches the command name in the help information
        bofs = {name: metadata for name, metadata in beaconCommands.items() if len(script.paths(name, 'beacon_inline_execute')) > 0}
        # Enumerate all code paths from the bof alias to bof_pack
        for bofName in bofs.keys():
            for path in script.paths(bofName, 'bof_pack'):
                # If a code path is found, enumerate all statements in the
                # function that uses bof_pack to identify all format strings
                # it uses
                walk(script.function(path[-2]), find_bof_pack)
                bofs[bofName]['arg_formats'] |= bofArgFormats
    print(json.dumps(bofs, indent=4, cls=JsonEncoder))
else:
    print('{} <path>'.format(sys.argv[0]))