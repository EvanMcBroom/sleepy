# -*- coding: utf-8 -*-
# Replace all code related to reading a beacon object file (BOF)
# from the file system in a sleep script with custom code. The
# script will define the variable $bofName which you may use
# in your custom code. The custom code is expected to be a function
# call that will replace the 2nd arg to beacon_inline_execute.
# This is meant to be a generic example script and will not work
# on all sleep scripts you use it own.
#
# Example usage:
#   cat EOF<< > new_code.cna
#   download_bof($bofName . "." . barch() . ".o")
#   EOF
#   ./replace_bofs.py new_code.cna original_code.cna

import sys
import sleepy.ast
from sleepy.parser import *

internalFunctions = list()
prefix = ''

beaconCommands = list()
def find_beacon_command_register(node):
    if isinstance(node, Call) and node.function == 'beacon_command_register':
        # We're assuming the simple format of beacon_command_register("", ...) is used
        beaconCommands.append(node.args[0].value)
    return node

# Including readbof for its use in CNAs authored by TrustedSec
functionsToRemove = ['berror', 'closef', 'openf', 'readb', 'readbof']
def remove_code(node):
    return string("") \
        if (isinstance(node, Call) and node.function in functionsToRemove) \
        or isinstance(node, Return) \
        else node

newArgument = None
def update_beacon_inline_execute(node):
    # Replace the 2nd argument to beacon_inline_execute with our custom call
    if isinstance(node, Call) and node.function == 'beacon_inline_execute':
        node.args[1] = newArgument
    return node

if len(sys.argv) > 2:
    pathToNewCode = sys.argv[1]
    pathToOriginalCode = sys.argv[2]
    parser = SleepParser(quiet=True)
    with open(pathToNewCode, 'r') as file:
        newArgument = parser.parse(file.read() + ';').body[0]
        with open(pathToOriginalCode, 'r') as file:
            script = parser.parse(file.read(), tracking=True)
            # Filter any empty statements that may have been generated by syntax errors
            script.body = [_ for _ in script.body if _]
            # Enumerate all bof names
            script = walk(script, find_beacon_command_register)
            # Filter the beacon commands to the ones that use a bof
            bofs = [name for name in beaconCommands if len(script.paths(name, 'beacon_inline_execute')) > 0]
            for bof in bofs:
                functionsToModify = [path[-2] for path in script.paths(bof, 'beacon_inline_execute')]
                for index, statement in enumerate(script.body):
                    if isinstance(statement, EnvBridge) and statement.identifier in functionsToModify:
                        # Add '$bofName = "..."' to the start of the function
                        statement.body.body = [BinOp(left='$bofName', op='=', right=bof)] + statement.body.body
                        # Remove code related to interacting with the file system,
                        # reporting errors, and returning early.
                        script.body[index] = walk(script.body[index], remove_code)
        # Update all beacon_inline_execute code to use our custom code
        script = walk(script, update_beacon_inline_execute)
        print(sleepy.ast.format(script))
else:
    print('{} <path to new code> <path to original code>'.format(sys.argv[0]))